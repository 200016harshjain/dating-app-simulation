# -*- coding: utf-8 -*-
"""dating-sim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-Tsj_hRgLmdrCx0wUFGi8R2-4p3uj7zs
"""

#population - 100,000
# men - 70%
# women - 30 %
# give everyone a rating between 1-10
# matching algorithm -> every day, men can pick up random 20 women and if they're in +-2 of their score it's a match (issues with this )
# same for women, random 20 men -> +-2 then it's a match
# can allow multiple matches for each person
# check after say 2 weeks



# ideas 
# rating slightly skewed towards 6 7 8
# matching algorithm - maybe on a grid idk
# matching critieria, give women +-1 or lesser matches idk
# this doesnt make sense, a man rated 10 has zero matches as he got matched with a 3, need to think about a better way on how to do match


#To Do
#logical bug mentioned in the main cell
#see how to overlay the graphs 
#figure out if we can do some homosexual modeling 
  # % of straight, lesbian/gay women/men and then bisexual (for bisexual would also need some % of who they're into)

import pandas as pd
import random
import numpy as np

population = 100000
men_population = int(0.75 * population)
women_population = int(0.25 * population)
matches_per_day_men = 10
matches_per_day_women = 10
number_of_days = 14
matching_criteria_for_men = 2
matching_criteria_for_women = 1
matching_criteria = min(matching_criteria_for_men,matching_criteria_for_women)
#take minimum of matching criteria -> see if women have a +/- 2

men_ratings =  [0] * men_population
#making a list where we store the ratings of men, randomly generate from 1-10
for i in range(len(men_ratings)):
  men_ratings[i] = generate_random_rating()

women_ratings = [0] * women_population
for i in range(len(women_ratings)):
  women_ratings[i] = generate_random_rating()


men_matches = [0] * men_population
#making a list where we store the number of matches of men, since it's the same size as 'men_ratings', the indexes match so men_rating[x] will have his matches stored in men_matches[x] (x being an index)
women_matches = [0] * women_population

for k in range(10):  #14 is like doing this for 14 days 
  for i in range(len(men_matches)): #iterate over all men
    current_rating = men_ratings[i] # get current 'rating'
    searching_women = random_match_index(matches_per_day_men,women_population) #get a list containing the index of 20 women
    
    for j in range(len(searching_women)):
      #for each of these women, check if the rating is within range for the man in question, if yes call it a match for both #here we end up using minimum of (men,women) standards
      
      if current_rating - matching_criteria <= women_ratings[searching_women[j]] <= current_rating + matching_criteria :
        men_matches[i] = men_matches[i] + 1
        women_matches[searching_women[j]] = women_matches[searching_women[j]] + 1

#just swapped men and women here
  for i in range(len(women_matches)):
    current_rating = women_ratings[i]
    searching_men = random_match_index(matches_per_day_women,men_population)

    for j in range(len(searching_men)):
      if current_rating - matching_criteria <= men_ratings[searching_men[j]] <= current_rating + matching_criteria :
        women_matches[i] = women_matches[i] + 1
        men_matches[searching_men[j]] = men_matches[searching_men[j]] + 1

#current code has a bug -> right now if I match with someone, I can match again with them in the next iteration, may  not need to fix (population inflow/outflow)
#probably better to fix, could have a dictionary (index list) pair storing the matches of a person and check accordingly (see if this impacts )

#plotting histograms of data for men
import numpy as np
import scipy.stats as stats
import pylab as pl
sorted(men_matches)
fit = stats.norm.pdf(men_matches, np.mean(men_matches), np.std(men_matches))  #this is a fitting indeed



pl.hist(men_matches,normed=True)      #use this to draw histogram of your data

pl.show()

#histogram of data for women
sorted(women_matches)
fit = stats.norm.pdf(women_matches, np.mean(women_matches), np.std(women_matches))  #this is a fitting indeed


pl.hist(women_matches,normed=True)      #use this to draw histogram of your data

pl.show()

#getting the gini coefficient and lorenz curve to calculate inequality
#reference https://medium.com/@worstonlinedater/tinder-experiments-ii-guys-unless-you-are-really-hot-you-are-probably-better-off-not-wasting-your-2ddf370a6e9a
#note, the maximum gini coefficent obtained till now was 0.25 (70/30 men:women with some other settings i dont remember). real world according to article has 0.50ish


import numpy as np
import matplotlib.pyplot as plt

# ensure your arr is sorted from lowest to highest values first!
total_matches = men_matches+ women_matches
total_matches = np.asarray(total_matches)
sorted(total_matches)

def gini(arr):
    count = arr.size
    coefficient = 2 / count
    indexes = np.arange(1, count + 1)
    weighted_sum = (indexes * arr).sum()
    total = arr.sum()
    constant = (count + 1) / count
    return coefficient * weighted_sum / total - constant


def lorenz(arr):
    # this divides the prefix sum by the total sum
    # this ensures all the values are between 0 and 1.0
    scaled_prefix_sum = arr.cumsum() / arr.sum()
    # this prepends the 0 value (because 0% of all people have 0% of all wealth)
    return np.insert(scaled_prefix_sum, 0, 0)

# show the gini index!
print(gini(total_matches))

lorenz_curve = lorenz(total_matches)

# we need the X values to be between 0.0 to 1.0
plt.plot(np.linspace(0.0, 1.0, lorenz_curve.size), lorenz_curve)
# plot the straight line perfect equality curve
plt.plot([0,1], [0,1])
plt.show()



#generate random number from 1 to 10
def generate_random_rating():
  return random.randrange(10)+1

#get a list of indexes of either men/mwomen 
def random_match_index(matches_to_be_returned, searching_within):

  match_indexes = [0] * matches_to_be_returned
  for i in range(len(match_indexes)):
    match_indexes[i] = random.randrange(searching_within)
  return match_indexes



